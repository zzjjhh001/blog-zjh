### 整体流程
字节->字节流解码->字符->输入流预处理->统一字符->令牌化->令牌标签->解析HTML生成DOM树，同时加载CSS生成CSSOM树->DOM树，CSSOM树->渲染引擎执行->渲染树->开始布局就是计算元素的大小位置,将所有相对值都转换为屏幕上的绝对像素->布局->遍历布局树->绘制记录->渲染引擎会根据绘制记录去绘制
### 字节流解码
浏览器通过HTTP协议收到的文档是字节数据，然后浏览器通过'编码嗅探算法'确定字符编码，然后根据字符编码把字节数据解码，生成了代码
### 输入流预处理
通过解码得到的字符流数据，在进入解析环节需要一些预处理操作，比如：将换行符转换成统一的格式。生成规范化的字符流数据，把字符数据进行统一格式化的过程称之为"输入流预处理"
### 令牌化
#### 将字符数据转化为令牌
令牌化：其过程是使用了一种类似状态机的算法,每次接受一个或多个输入流中的字符，然后根据当前状态和这些字符来更细你下一个状态，也就是说不同状态下接受统一昂的字符数据可能会产生不一样的结果。比如：收到"body",在标签打开状态下解析成标签，标签关闭状态下解析成文本节点
1. 初始化为“数据状态”（Data State）；
2. 匹配到字符<，状态切换到“标签打开状态”（Tag Open State）；
3. 匹配到字符!，状态切换至“标签声明打开状态”（Markup Declaration Open State），后续 7个字符可以组成字符串DOCTYPE，跳转到“DOCTYPE 状态”（DOCTYPE State）；
4. 匹配到字符为空格，当前状态切换至“DOCTYPE名称之前状态”（Before DOCTYPE Name State）；
5. 匹配到字符串html，创建一个新的DOCTYPE标记，标记的名字为“html” ，然后当前状态切换至“DOCTYPE名字状态”（DOCTYPE Name State）；
6. 匹配到字符>，跳转到“数据状态”并且释放当前的 DOCTYPE 标记；
7. 匹配到字符<，切换到“标签打开状态”；
8. 匹配到字符h，创建一个新的起始标签标记，设置标记的标签名为空，当前状态切换至 “标签名称状态”（Tag Name State）；
9. 从字符h开始解析，将解析的字符一个一个添加到创建的起始标签标记的标签名中，直到匹配到字符>，此时当前状态切换至 “数据状态” 并释放当前标记，当前标记的标签名为 “html” 。
10. 解析后续的的方式与一致，创建并释放对应的起始标签标记，解析完毕后，当前状态处于 “数据状态”；
11. 匹配到字符串“标记” ，针对每一个字符，创建并释放一个对应的字符标记，解析完毕后，当前状态仍然处于 “数据状态” ；
12. 匹配到字符<，进入 “标签打开状态” ；
13. 匹配到字符/，进入 “结束标签打开状态”（End Tag Open State）；
14. 匹配到字符b，创建一个新的结束标签标记，设置标记的标签名为空，当前状态切换至“标签名称状态”（Tag Name State）；
15. 重新从字符 b 开始解析，将解析的字符一个一个添加到创建的结束标签标记的标签名中，直到匹配到字符>，此时当前状态切换至 “数据状态” 并释放当前标记，当前标记的标签名为 “body”；
16. 解析的方式与一样；
17. 所有的html标签和文本解析完成后，状态切换至“数据状态” ，一旦匹配到文件结束标志符（EOF），则释放EOF标记。

##### 遇到script标签
1. 内联代码：也就是在script标签中直接写代码，那么解析过程会暂停，执行权限会转给 JavaScript脚本引擎，待JavaScript 脚本执行完成之后再交由渲染引擎继续解析。
   1. 如果代码中有document.write，那么就会返回输入流预解析阶段，然后到内容插入，再次执行预解析。
2. 外链脚本
首先请求文件，然后交给JS脚本引擎执行，执行完毕，在由渲染引擎解析。
3. 默认的script都会阻塞渲染引擎。但是有的属性会改变这个
- async立即请求文件，但是不阻塞渲染引擎，加载完毕后阻塞渲染引擎，立即执行代码
- defer立即请求文件，不阻塞渲染引擎，直到解析完HTML后再执行代码
- HTML5的type属性为module，效果和defer一样。

#### 解析HTML生成DOM树
- 上一步已经把各种标签令牌化了，这一步会把标签送入向DOM树上添加
- 浏览器在创建解析器时，会创建一个document对象，在树构建阶段,Document会作为根节点被不断的修改和扩充，标记步骤产生的令牌会送到树构建器处理。
- HTML5标准中定义了每类令牌对应的DOM元素
- 当树构建器接收到令牌时就会创建与这个令牌对应的DOM元素，并将该元素插入到DOM树中
- 因为要纠正元素标签嵌套错位的问题和处理未关闭的元素标签，所以DOM元素会被插入到一个开发元素栈中

### 由CSS生成CSSOM树

## 从DOM树到渲染
有了DOM和CSSOM树后，浏览器的渲染引擎就开始生成页面了
### 构建渲染树
- DOM树包含的结构元素内容和CSSOM树包含的样式规则是独立的，所以为了方便渲染，需要将他们合并为一个渲染树
- 从DOM树的根节点开始遍历，然后在CSSOM树上找到对应节点的样式。
- 遍历时会忽略一些不用渲染的节点(脚本标记:script,元标记:head，title，meta)还有不可见的节点(display:none).同时会将伪类元素加到渲染树中。
- 遍历生成渲染树时，顺序是自下向上的，因为CSSOM匹配时，是自右向左的。

### 布局
生成渲染树之后，就开始布局阶段，就是计算元素的位置和大小
布局完成后会输出对应的“盒模型”，它会精确地捕获每个元素的确切位置和大小，将所有相对值都转换为屏幕上的绝对像素
### 绘制
绘制就是将渲染树中的阶段转换成屏幕上实际像素的过程
- 这一步不是直接绘制的，因为只知道每个元素的大小和位置，但是不知道他们的层级，就是谁在上谁在下，谁会遮住谁。
- 所以第一步是遍历布局树，生成绘制记录，然后渲染引擎会根据绘制记录去绘制响应的内容。

## 回流和重绘
判断回流和重绘：只要引起页面布局改变就是回流。
### 回流
- 修改DOM树，改变页面布局
- 窗口尺寸改变
- 文本信息改变
- 第一次渲染页面

### 重绘
- 颜色改变
- 透明度改变