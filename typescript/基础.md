## ts
### tips
1. 如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查
2. 定义式时赋值会类型推断

### 接口
#### 在接口中定义任意的属性
```typescript
interface Test {
  name: string;
  [propName: string]: string;
}
// 注意任意属性的类型必须包含显式声明的属性的类型
```
#### 在接口中定义只读属性
只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：就是第一次给对象赋值的时候必须声明值，然后后续在修改就报错
```typescript
interface Test {
  readonly name: string;
}
let a: Test = {
  name: '2'
}
a.name = '3' // 报错
```
#### 接口定义函数
```typescript
interface SearchFunc {
  (source: string, subString: string): boolean;
}

let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
  return source.search(subString) !== -1;
}
```
### 数组
1. let array: number[];
2. let array: Array<number>;
3. interface t {
  [index: number]: number
}
4. 第三种多用来定义类数组的类型
### 函数
```typescript
let mySum: (x: number, y: number) => number = function (x: number, y: number): number {
    return x + y;
};
这里的=>不是肩头函数，是指定类型
```
### 参数默认值
```typescript
// TypeScript 会将添加了默认值的参数识别为可选参数
function buildName(firstName: string, lastName: string = 'Cat') {
    return firstName + ' ' + lastName;
}
function buildName(firstName: string = 'Tom', lastName: string) {
    return firstName + ' ' + lastName;
}
```
### 重载
```typescript
function reverse(x: number): number;
function reverse(x: string): string;
function reverse(x: number | string): number | string | void {
    if (typeof x === 'number') {
        return Number(x.toString().split('').reverse().join(''));
    } else if (typeof x === 'string') {
        return x.split('').reverse().join('');
    }
}
```
### 类型断言
as
就是为了通过编译，人为的确定它的类型
TODO: 弄懂案例：类型断言的限制
### 非空断言
在字段后边加上!,就是非空断言，就是指前面的字段不可能时undefined或者null;
```typescript
function test(value?: string) {
  return value!;
}
```
### 重载
typescript的重载至少要三个
```typescript
class Test {
  constructor() {
    
  }
  sayHi(): void;
  sayHi(name: string): string;
  sayHi(name?: string): void | string {
    if(name) {
      return '123' + name;
      } else {
      console.log('123');
    }
  }
}
```
### 重写
方法名称，参数名称，返回值类型都一致。
```typescript
class Person {
  constructor() {
  }
  sayHi() {
    console.log(222);
  }
}
class User extends Person {
  constructor() {
    super()
  }
  sayHi() {
    console.log(333);
  }
}
```
### 属性修饰符
#### public
public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的
#### private
修饰的属性或方法是私有的，不能在声明它的类的外部访问
#### protected
修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的
#### static
定义静态属性和方法
```typescript
class Test {
  static name: string = '22';
  static handle(): void {
    console.log(222);
  }
}
```
#### readonly
1. 只读属性关键字，只允许出现在属性声明或索引签名或构造函数中。
2. 注意如果 readonly 和其他访问修饰符同时存在的话，需要写在其后面。
```typescript
class Test {
  constructor(public readonly name: string) {
  }
}
```
### 参数属性
修饰符和readonly还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁。
```typescript
class Test {
  constructor(public name: string) {

  }
}
// 等同于
class test {
  public name: string;
  constructor(name: string) {
    this.name = name;
  }
}
```
### 接口
当我们在声明 class Point 时，除了会创建一个名为 Point 的类之外，同时也创建了一个名为 Point 的类型（实例的类型）。
TypeScript支持接口继承类
```typescript
interface Alarm {
    alert(): void;
}

class Door {
}

class SecurityDoor extends Door implements Alarm {
    alert() {
        console.log('SecurityDoor alert');
    }
}

class Car implements Alarm {
    alert() {
        console.log('Car alert');
    }
}
```

### 泛型
```typescript
function test<T>(name: T): Array<T> {
  let d: T[] = [];
  d.push(name);
  return d;
}

function test2<T extends U, U>(one: T, two: U): U[] {
  return [one, two];
}
```
#### 类中使用泛型
```typescript
class Test<T> {
  name: T;
  add: (a: T, b: T) => T
}
```
#### 接口中使用泛型
```typescript
interface CreateArrayFunc<T> {
  (length: number, value: T): Array<T>;
}
```
#### 泛型的默认类型
```typescript
function test<T= string>(a: string, b: T): T {

}
```
### enum
1. 枚举初始化之后不可修改。
2. 值默认是 0，1，2。 当初始化时不给值时，会推测值。加一递增

### 合并
同名的接口和函数以及类都会合并。
接口内部同名的属性，类型必须一致，否则抛错。

### type和interface
```typescript
interface A {
  name: string;
}
type B = A & { age: number };
type C = {
  name: string;
}
interface D extends C {
  age: number;
} // D: { age:number, name: string }
```

### & 和 ｜
& 表示同时满足
｜表示满足其一即可
```typescript
interface A {
  name: string | number;
}
interface B {
  age: number
}
let a: A&B;
a要有name和age
```
### extends
1. 类继承时使用
2. 类型计算时使用
```typescript
type C = B extends A ? A : B;
```
3. 类型继承使用
```typescript
interface B {
  name: string;
}
interface A extends B {
  age: number;
}
```
### as const
一种类型断言，表示最窄的类型
const a = [1, 2] as const;
a的类型就是 readonly[1, 2];
默认的类型推断a是 number[]
let b = 2 as const; // b:2
let b = 2; // b:number
### typeof
从变量获取类型。
const a = 2;
typeof a // 2
const d = {
  name: '232';
}
typeof a // { name: string }
### keyof
获取类型的key值
class的private属性和protected属性不会被keyof获取到。

